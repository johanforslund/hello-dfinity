"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeActorFactory = exports.Actor = exports.CanisterInstallMode = void 0;
const buffer_1 = require("buffer/");
const agent_1 = require("./agent");
const management_1 = require("./canisters/management");
const certificate_1 = require("./certificate");
const http_agent_types_1 = require("./http_agent_types");
const IDL = __importStar(require("./idl"));
const principal_1 = require("./principal");
const request_id_1 = require("./request_id");
const types_1 = require("./types");
/**
 * The mode used when installing a canister.
 */
var CanisterInstallMode;
(function (CanisterInstallMode) {
    CanisterInstallMode["Install"] = "install";
    CanisterInstallMode["Reinstall"] = "reinstall";
    CanisterInstallMode["Upgrade"] = "upgrade";
})(CanisterInstallMode = exports.CanisterInstallMode || (exports.CanisterInstallMode = {}));
const metadataSymbol = Symbol.for('ic-agent-metadata');
/**
 * An actor base class. An actor is an object containing only functions that will
 * return a promise. These functions are derived from the IDL definition.
 */
class Actor {
    constructor(metadata) {
        this[metadataSymbol] = metadata;
    }
    /**
     * Get the Agent class this Actor would call, or undefined if the Actor would use
     * the default agent (global.ic.agent).
     */
    static agentOf(actor) {
        return actor[metadataSymbol].agent;
    }
    /**
     * Get the interface of an actor, in the form of an instance of a Service.
     * @param actor The actor to get the interface of.
     */
    static interfaceOf(actor) {
        return actor[metadataSymbol].service;
    }
    static canisterIdOf(actor) {
        return actor[metadataSymbol].canisterId;
    }
    static async install(fields, config) {
        const mode = fields.mode === undefined ? CanisterInstallMode.Install : fields.mode;
        // Need to transform the arg into a number array.
        const arg = fields.arg ? [...fields.arg] : [];
        // Same for module.
        const wasmModule = [...fields.module];
        const canisterId = typeof config.canisterId === 'string'
            ? principal_1.Principal.fromText(config.canisterId)
            : config.canisterId;
        const computerAllocation = fields.computerAllocation !== undefined ? [fields.computerAllocation] : [];
        const memoryAllocation = fields.memoryAllocation !== undefined ? [fields.memoryAllocation] : [];
        await management_1.getManagementCanister(config).install_code({
            mode: { [mode]: null },
            arg,
            wasm_module: wasmModule,
            canister_id: canisterId,
            compute_allocation: computerAllocation,
            memory_allocation: memoryAllocation,
        });
    }
    static async createCanister(config) {
        const { canister_id: canisterId } = await management_1.getManagementCanister(config || {}).create_canister();
        return canisterId;
    }
    static async createAndInstallCanister(interfaceFactory, fields, config) {
        const canisterId = await this.createCanister(config);
        await this.install(Object.assign({}, fields), Object.assign(Object.assign({}, config), { canisterId }));
        return this.createActor(interfaceFactory, Object.assign(Object.assign({}, config), { canisterId }));
    }
    static createActorClass(interfaceFactory) {
        const service = interfaceFactory({ IDL });
        class CanisterActor extends Actor {
            constructor(config) {
                const canisterId = typeof config.canisterId === 'string'
                    ? principal_1.Principal.fromText(config.canisterId)
                    : config.canisterId;
                super(Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), config), { canisterId,
                    service }));
            }
        }
        for (const [methodName, func] of service._fields) {
            CanisterActor.prototype[methodName] = _createActorMethod(methodName, func);
        }
        return CanisterActor;
    }
    static createActor(interfaceFactory, configuration) {
        return new (this.createActorClass(interfaceFactory))(configuration);
    }
}
exports.Actor = Actor;
// IDL functions can have multiple return values, so decoding always
// produces an array. Ensure that functions with single or zero return
// values behave as expected.
function decodeReturnValue(types, msg) {
    const returnValues = IDL.decode(types, buffer_1.Buffer.from(msg));
    switch (returnValues.length) {
        case 0:
            return undefined;
        case 1:
            return returnValues[0];
        default:
            return returnValues;
    }
}
const REQUEST_STATUS_RETRY_WAIT_DURATION_IN_MSECS = 500;
const DEFAULT_ACTOR_CONFIG = {
    maxAttempts: 30,
    throttleDurationInMSecs: REQUEST_STATUS_RETRY_WAIT_DURATION_IN_MSECS,
};
function _createActorMethod(methodName, func) {
    if (func.annotations.includes('query')) {
        return async function (...args) {
            const agent = this[metadataSymbol].agent || agent_1.getDefaultAgent();
            const cid = this[metadataSymbol].canisterId;
            const arg = IDL.encode(func.argTypes, args);
            const result = await agent.query(cid, { methodName, arg });
            switch (result.status) {
                case "rejected" /* Rejected */:
                    throw new Error(`Query failed:\n` +
                        `  Status: ${result.status}\n` +
                        `  Message: ${result.reject_message}\n`);
                case "replied" /* Replied */:
                    return decodeReturnValue(func.retTypes, result.reply.arg);
            }
        };
    }
    else {
        return async function (...args) {
            const agent = this[metadataSymbol].agent || agent_1.getDefaultAgent();
            const cid = this[metadataSymbol].canisterId;
            const { maxAttempts, throttleDurationInMSecs } = this[metadataSymbol];
            const arg = IDL.encode(func.argTypes, args);
            const { requestId, response } = await agent.call(cid, { methodName, arg });
            if (!response.ok) {
                throw new Error([
                    'Call failed:',
                    `  Method: ${methodName}(${args})`,
                    `  Canister ID: ${cid.toHex()}`,
                    `  Request ID: ${request_id_1.toHex(requestId)}`,
                    `  HTTP status code: ${response.status}`,
                    `  HTTP status text: ${response.statusText}`,
                ].join('\n'));
            }
            return _requestStatusAndLoop(agent, requestId, bytes => {
                if (bytes !== undefined) {
                    return decodeReturnValue(func.retTypes, bytes);
                }
                else if (func.retTypes.length === 0) {
                    return undefined;
                }
                else {
                    throw new Error(`Call was returned undefined, but type [${func.retTypes.join(',')}].`);
                }
            }, maxAttempts, maxAttempts, throttleDurationInMSecs);
        };
    }
}
async function _requestStatusAndLoop(agent, requestId, decoder, attempts, maxAttempts, throttle) {
    const path = [types_1.blobFromText('request_status'), requestId];
    const state = await agent.readState({ paths: [path] });
    const cert = new certificate_1.Certificate(state, agent);
    const verified = await cert.verify();
    if (!verified) {
        throw new Error('Fail to verify certificate');
    }
    const maybeBuf = cert.lookup([...path, types_1.blobFromText('status')]);
    let status;
    if (typeof maybeBuf === 'undefined') {
        // Missing requestId means we need to wait
        status = http_agent_types_1.RequestStatusResponseStatus.Unknown;
    }
    else {
        status = maybeBuf.toString();
    }
    switch (status) {
        case http_agent_types_1.RequestStatusResponseStatus.Replied: {
            const response = cert.lookup([...path, types_1.blobFromText('reply')]);
            return decoder(response);
        }
        case http_agent_types_1.RequestStatusResponseStatus.Received:
        case http_agent_types_1.RequestStatusResponseStatus.Unknown:
        case http_agent_types_1.RequestStatusResponseStatus.Processing:
            if (--attempts === 0) {
                throw new Error(`Failed to retrieve a reply for request after ${maxAttempts} attempts:\n` +
                    `  Request ID: ${request_id_1.toHex(requestId)}\n` +
                    `  Request status: ${status}\n`);
            }
            // Wait a little, then retry.
            return new Promise(resolve => setTimeout(resolve, throttle)).then(() => _requestStatusAndLoop(agent, requestId, decoder, attempts, maxAttempts, throttle));
        case http_agent_types_1.RequestStatusResponseStatus.Rejected:
            const rejectCode = cert.lookup([...path, types_1.blobFromText('reject_code')]).toString();
            const rejectMessage = cert.lookup([...path, types_1.blobFromText('reject_message')]).toString();
            throw new Error(`Call was rejected:\n` +
                `  Request ID: ${request_id_1.toHex(requestId)}\n` +
                `  Reject code: ${rejectCode}\n` +
                `  Reject text: ${rejectMessage}\n`);
        case http_agent_types_1.RequestStatusResponseStatus.Done:
            // This is _technically_ not an error, but we still didn't see the `Replied` status so
            // we don't know the result and cannot decode it.
            throw new Error(`Call was marked as done but we never saw the reply:\n` +
                `  Request ID: ${request_id_1.toHex(requestId)}\n`);
    }
    throw new Error('unreachable');
}
// Make an actor from an actor interface.
//
// Allows for one HTTP agent for the lifetime of the actor:
//
// ```
// const actor = makeActor(actorInterface)({ agent });
// const reply = await actor.greet();
// ```
//
// or using a different HTTP agent for the same actor if necessary:
//
// ```
// const actor = makeActor(actorInterface);
// const reply1 = await actor(agent1).greet();
// const reply2 = await actor(agent2).greet();
// ```
function makeActorFactory(actorInterfaceFactory) {
    return (config) => {
        return Actor.createActor(actorInterfaceFactory, config);
    };
}
exports.makeActorFactory = makeActorFactory;
//# sourceMappingURL=actor.js.map