"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Principal = void 0;
const base32_js_1 = __importDefault(require("base32.js"));
const buffer_1 = require("buffer/");
const types_1 = require("./types");
const getCrc_1 = require("./utils/getCrc");
const sha224_1 = require("./utils/sha224");
const SELF_AUTHENTICATING_SUFFIX = 2;
const ANONYMOUS_SUFFIX = 4;
class Principal {
    constructor(_blob) {
        this._blob = _blob;
        this._isPrincipal = true;
    }
    static anonymous() {
        return new this(types_1.blobFromUint8Array(new Uint8Array([ANONYMOUS_SUFFIX])));
    }
    static selfAuthenticating(publicKey) {
        const sha = sha224_1.sha224(publicKey);
        return new this(types_1.blobFromUint8Array(new Uint8Array([...sha, SELF_AUTHENTICATING_SUFFIX])));
    }
    static fromHex(hex) {
        return new this(types_1.blobFromHex(hex));
    }
    static fromText(text) {
        const canisterIdNoDash = text.toLowerCase().replace(/-/g, '');
        const decoder = new base32_js_1.default.Decoder({ type: 'rfc4648', lc: false });
        const result = decoder.write(canisterIdNoDash).finalize();
        let arr = new Uint8Array(result);
        arr = arr.slice(4, arr.length);
        return new this(types_1.blobFromUint8Array(arr));
    }
    static fromBlob(blob) {
        return new this(blob);
    }
    isAnonymous() {
        return this._blob.byteLength === 1 && this._blob[0] === ANONYMOUS_SUFFIX;
    }
    toBlob() {
        return this._blob;
    }
    toHash() {
        return this._blob;
    }
    toHex() {
        return types_1.blobToHex(this._blob).toUpperCase();
    }
    toText() {
        const checksumArrayBuf = new ArrayBuffer(4);
        const view = new DataView(checksumArrayBuf);
        view.setUint32(0, getCrc_1.getCrc32(this.toHex().toLowerCase()), false);
        const checksum = Uint8Array.from(buffer_1.Buffer.from(checksumArrayBuf));
        const bytes = Uint8Array.from(this._blob);
        const array = new Uint8Array([...checksum, ...bytes]);
        const encoder = new base32_js_1.default.Encoder({ type: 'rfc4648', lc: false });
        const result = encoder.write(array).finalize().toLowerCase();
        const matches = result.match(/.{1,5}/g);
        return matches ? matches.join('-') : '';
    }
    toString() {
        return this.toText();
    }
}
exports.Principal = Principal;
//# sourceMappingURL=principal.js.map