"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpAgent = void 0;
const buffer_1 = require("buffer/");
const actor = __importStar(require("../actor"));
const auth_1 = require("../auth");
const cbor = __importStar(require("../cbor"));
const http_agent_transforms_1 = require("../http_agent_transforms");
const http_agent_types_1 = require("../http_agent_types");
const principal_1 = require("../principal");
const request_id_1 = require("../request_id");
const types_1 = require("../types");
const API_VERSION = 'v1';
// Default delta for ingress expiry is 5 minutes.
const DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS = 5 * 60 * 1000;
function getDefaultFetch() {
    const result = typeof window === 'undefined'
        ? typeof global === 'undefined'
            ? typeof self === 'undefined'
                ? undefined
                : self.fetch.bind(self)
            : global.fetch.bind(global)
        : window.fetch.bind(window);
    if (!result) {
        throw new Error('Could not find default `fetch` implementation.');
    }
    return result;
}
// A HTTP agent allows users to interact with a client of the internet computer
// using the available methods. It exposes an API that closely follows the
// public view of the internet computer, and is not intended to be exposed
// directly to the majority of users due to its low-level interface.
//
// There is a pipeline to apply transformations to the request before sending
// it to the client. This is to decouple signature, nonce generation and
// other computations so that this class can stay as simple as possible while
// allowing extensions.
class HttpAgent {
    constructor(options = {}) {
        this._pipeline = [];
        if (options.source) {
            this._pipeline = [...options.source._pipeline];
            this._identity = options.source._identity;
            this._fetch = options.source._fetch;
            this._host = options.source._host;
            this._credentials = options.source._credentials;
        }
        else {
            this._fetch = options.fetch || getDefaultFetch() || fetch.bind(global);
        }
        if (options.host) {
            if (!options.host.match(/^[a-z]+:/) && typeof window !== 'undefined') {
                this._host = new URL(window.location.protocol + '//' + options.host);
            }
            else {
                this._host = new URL(options.host);
            }
        }
        else if (options.source) {
            // Safe to ignore here.
            this._host = options.source._host;
        }
        else {
            const location = window === null || window === void 0 ? void 0 : window.location;
            if (!location) {
                throw new Error('Must specify a host to connect to.');
            }
            this._host = new URL(location + '');
        }
        if (options.credentials) {
            const { name, password } = options.credentials;
            this._credentials = `${name}${password ? ':' + password : ''}`;
        }
        this._identity = Promise.resolve(options.identity || new auth_1.AnonymousIdentity());
    }
    addTransform(fn, priority = fn.priority || 0) {
        // Keep the pipeline sorted at all time, by priority.
        const i = this._pipeline.findIndex(x => (x.priority || 0) < priority);
        this._pipeline.splice(i >= 0 ? i : this._pipeline.length, 0, Object.assign(fn, { priority }));
    }
    async getPrincipal() {
        return this._identity ? (await this._identity).getPrincipal() : principal_1.Principal.anonymous();
    }
    async call(canisterId, fields, identity) {
        const id = await (identity !== undefined ? identity : this._identity);
        const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || principal_1.Principal.anonymous();
        return this.submit({
            request_type: http_agent_types_1.SubmitRequestType.Call,
            canister_id: typeof canisterId === 'string' ? principal_1.Principal.fromText(canisterId) : canisterId,
            method_name: fields.methodName,
            arg: fields.arg,
            sender: sender.toBlob(),
            ingress_expiry: new http_agent_transforms_1.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),
        }, id);
    }
    async install(canisterId, fields, identity) {
        const id = await (identity || this._identity);
        const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || principal_1.Principal.anonymous();
        return this.submit({
            request_type: http_agent_types_1.SubmitRequestType.InstallCode,
            canister_id: typeof canisterId === 'string' ? principal_1.Principal.fromText(canisterId) : canisterId,
            module: fields.module,
            arg: fields.arg || types_1.blobFromHex(''),
            sender: sender.toBlob(),
            ingress_expiry: new http_agent_transforms_1.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),
        }, id);
    }
    async createCanister(identity) {
        const id = await (identity || this._identity);
        const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || principal_1.Principal.anonymous();
        return this.submit({
            request_type: http_agent_types_1.SubmitRequestType.CreateCanister,
            sender: sender.toBlob(),
            ingress_expiry: new http_agent_transforms_1.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),
        }, id);
    }
    async query(canisterId, fields, identity) {
        const id = await (identity || this._identity);
        const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || principal_1.Principal.anonymous();
        return this.read({
            request_type: "query" /* Query */,
            canister_id: typeof canisterId === 'string' ? principal_1.Principal.fromText(canisterId) : canisterId,
            method_name: fields.methodName,
            arg: fields.arg,
            sender: sender.toBlob(),
            ingress_expiry: new http_agent_transforms_1.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),
        }, id);
    }
    async readState(fields, identity) {
        const id = await (identity || this._identity);
        const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || principal_1.Principal.anonymous();
        return this.read({
            request_type: "read_state" /* ReadState */,
            paths: fields.paths,
            sender: sender.toBlob(),
            ingress_expiry: new http_agent_transforms_1.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),
        }, id);
    }
    async status() {
        const headers = this._credentials
            ? {
                Authorization: 'Basic ' + btoa(this._credentials),
            }
            : {};
        const response = await this._fetch('' + new URL(`/api/${API_VERSION}/${"status" /* Status */}`, this._host), { headers });
        if (!response.ok) {
            throw new Error(`Server returned an error:\n` +
                `  Code: ${response.status} (${response.statusText})\n` +
                `  Body: ${await response.text()}\n`);
        }
        const buffer = await response.arrayBuffer();
        return cbor.decode(new Uint8Array(buffer));
    }
    makeActorFactory(actorInterfaceFactory) {
        return actor.makeActorFactory(actorInterfaceFactory);
    }
    _transform(request) {
        let p = Promise.resolve(request);
        for (const fn of this._pipeline) {
            p = p.then(r => fn(r).then(r2 => r2 || r));
        }
        return p;
    }
    async submit(submit, identity) {
        let transformedRequest = (await this._transform({
            request: {
                body: null,
                method: 'POST',
                headers: Object.assign({ 'Content-Type': 'application/cbor' }, (this._credentials ? { Authorization: 'Basic ' + btoa(this._credentials) } : {})),
            },
            endpoint: "submit" /* Submit */,
            body: submit,
        }));
        // Apply transform for identity.
        transformedRequest = await identity.transformRequest(transformedRequest);
        const body = cbor.encode(transformedRequest.body);
        // Run both in parallel. The fetch is quite expensive, so we have plenty of time to
        // calculate the requestId locally.
        const [response, requestId] = await Promise.all([
            this._fetch('' + new URL(`/api/${API_VERSION}/${"submit" /* Submit */}`, this._host), Object.assign(Object.assign({}, transformedRequest.request), { body })),
            request_id_1.requestIdOf(submit),
        ]);
        if (!response.ok) {
            throw new Error(`Server returned an error:\n` +
                `  Code: ${response.status} (${response.statusText})\n` +
                `  Body: ${await response.text()}\n`);
        }
        return {
            requestId,
            response: {
                ok: response.ok,
                status: response.status,
                statusText: response.statusText,
            },
        };
    }
    async read(request, identity) {
        // TODO: remove this any. This can be a Signed or UnSigned request.
        let transformedRequest = await this._transform({
            request: {
                method: 'POST',
                headers: Object.assign({ 'Content-Type': 'application/cbor' }, (this._credentials ? { Authorization: 'Basic ' + btoa(this._credentials) } : {})),
            },
            endpoint: "read" /* Read */,
            body: request,
        });
        // Apply transform for identity.
        transformedRequest = await identity.transformRequest(transformedRequest);
        const body = cbor.encode(transformedRequest.body);
        const response = await this._fetch('' + new URL(`/api/${API_VERSION}/${"read" /* Read */}`, this._host), Object.assign(Object.assign({}, transformedRequest.request), { body }));
        if (!response.ok) {
            throw new Error(`Server returned an error:\n` +
                `  Code: ${response.status} (${response.statusText})\n` +
                `  Body: ${await response.text()}\n`);
        }
        return cbor.decode(buffer_1.Buffer.from(await response.arrayBuffer()));
    }
}
exports.HttpAgent = HttpAgent;
//# sourceMappingURL=http.js.map